#include <memory>

#include "./include/puzzle.h"
#include "./include/utils.h"

// (ID + ( (ID * ID) * ID ) - ID)
//  a+b*c/d+e

// (1) exp → exp + term
// (2) exp → exp – term
// (3) exp → term
// (4) term → term * fact
// (5) term → term / fact
// (6) term → fact
// (7) fact → ID
// (8) fact → ( exp )

// type id = ID of string

// type exp =
//   | Plus of exp * term
//   | Minus of exp * term
//   | Term of term

// and term =
//   | Times of term * fact
//   | Divide of term * fact
//   | Fact of fact

// and fact =
//   | Identifier of id
//   | Parentheses of exp

enum class Dir {
  Left = 0,
  Right = 1,
};

enum class State {
  Fact = 0,
  Term = 1,
  Exp = 2,
};

struct Expr {
  std::string str;
  std::string path;
  int index;
  State state;
};

void peek(Expr &expr, char &l, char &r)
{
  if (expr.index > 0) {
    l = expr.str[expr.index-1];
  }
  if (expr.index < expr.str.size()-1) {
    r = expr.str[expr.index+1];
  }
}

Dir precidence(char &l, char &r)
{
  if (!r) return Dir::Left;
  if (!l) return Dir::Right;
  if ((l == '*' || l == '/') && ( r != '*' || r != '/')) return Dir::Left;
  return Dir::Right;
}

void eat(std::string &expr, int idx, Dir dir)
{
  if (dir == Dir::Left) {
    // ...
  } else {
    // ...
  }
}

bool update_state(Expr &expr, char op, Dir dir)
{
  if (op == '+' && dir == Dir::Left)
}

std::string evaluate_expr(std::string str, int index)
{
  Expr expr = { str, "", index, State::Fact};

  char left = 'l', right = 'r';
  while (left && right) {
    peek(expr, left, right);
    
    if (precidence(left, right) == Dir::Right) {
      update_state(expr, right, Dir::Left);
      eat();
    } else {
    }
  }
}

Puzzle ast_puzzle_create(long seed)
{
  (void)seed;

  std::string input = "a+b*c+X/e";
  std::string path = evaluate_expr(input);

  return {};
}
